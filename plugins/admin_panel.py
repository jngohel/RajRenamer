from config import Config
from helper.database import db
from helper.utils import get_seconds, extract_post_id
from pyrogram.types import Message
from pyrogram import Client, filters
from pyrogram.errors import FloodWait, InputUserDeactivated, UserIsBlocked, PeerIdInvalid
import os, sys, time, asyncio, logging, datetime

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
 
@Client.on_message(filters.command(["stats", "status"]) & filters.user(Config.ADMIN))
async def get_stats(bot, message):
    total_users = await db.total_users_count()
    uptime = time.strftime("%Hh%Mm%Ss", time.gmtime(time.time() - bot.uptime))    
    start_t = time.time()
    st = await message.reply('**Aá´„á´„á´‡êœ±êœ±ÉªÉ´É¢ TÊœá´‡ Dá´‡á´›á´€ÉªÊŸêœ±.....**')    
    end_t = time.time()
    time_taken_s = (end_t - start_t) * 1000
    await st.edit(text=f"**--Bá´á´› Sá´›á´€á´›á´œêœ±--** \n\n**âŒšï¸ Bá´á´› Uá´©á´›Éªá´á´‡:** {uptime} \n**ğŸŒ Cá´œÊ€Ê€á´‡É´á´› PÉªÉ´É¢:** `{time_taken_s:.3f} á´êœ±` \n**ğŸ‘­ Tá´á´›á´€ÊŸ Uêœ±á´‡Ê€êœ±:** `{total_users}`")

#Restart to cancell all process 
@Client.on_message(filters.private & filters.command("restart") & filters.user(Config.ADMIN))
async def restart_bot(b, m):
    await m.reply_text("ğŸ”„__Rá´‡êœ±á´›á´€Ê€á´›ÉªÉ´É¢.....__")
    os.execl(sys.executable, sys.executable, *sys.argv)

@Client.on_message(filters.command("broadcast") & filters.user(Config.ADMIN) & filters.reply)
async def broadcast_handler(bot: Client, m: Message):
    await bot.send_message(Config.LOG_CHANNEL, f"{m.from_user.mention} or {m.from_user.id} Iêœ± êœ±á´›á´€Ê€á´›á´‡á´… á´›Êœá´‡ BÊ€á´á´€á´…á´„á´€êœ±á´›......")
    all_users = await db.get_all_users()
    broadcast_msg = m.reply_to_message
    sts_msg = await m.reply_text("BÊ€á´á´€á´…á´„á´€êœ±á´› Sá´›á´€Ê€á´›á´‡á´…..!") 
    done = 0
    failed = 0
    success = 0
    start_time = time.time()
    total_users = await db.total_users_count()
    async for user in all_users:
        sts = await send_msg(user['_id'], broadcast_msg)
        if sts == 200:
           success += 1
        else:
           failed += 1
        if sts == 400:
           await db.delete_user(user['_id'])
        done += 1
        if not done % 20:
           await sts_msg.edit(f"BÊ€á´á´€á´…á´„á´€êœ±á´› IÉ´ PÊ€á´É¢Ê€á´‡êœ±êœ±: \nTá´á´›á´€ÊŸ Uêœ±á´‡Ê€êœ± {total_users} \nCá´á´á´©ÊŸá´‡á´›á´‡á´…: {done} / {total_users}\nSá´œá´„á´„á´‡êœ±êœ±: {success}\nFá´€ÉªÊŸá´‡á´…: {failed}")
    completed_in = datetime.timedelta(seconds=int(time.time() - start_time))
    await sts_msg.edit(f"BÊ€á´á´€á´…á´„á´€êœ±á´› Cá´á´á´©ÊŸá´‡á´›á´‡á´…: \nCá´á´á´©ÊŸá´‡á´›á´‡á´… IÉ´ `{completed_in}`.\n\nTá´á´›á´€ÊŸ Uêœ±á´‡Ê€êœ± {total_users}\nCá´á´á´©ÊŸá´‡á´›á´‡á´…: {done} / {total_users}\nSá´œá´„á´„á´‡êœ±êœ±: {success}\nFá´€ÉªÊŸá´‡á´…: {failed}")
           
async def send_msg(user_id, message):
    try:
        await message.copy(chat_id=int(user_id))
        return 200
    except FloodWait as e:
        await asyncio.sleep(e.value)
        return send_msg(user_id, message)
    except InputUserDeactivated:
        logger.info(f"{user_id} : Dá´‡á´€á´„á´›Éªá´ á´€á´›á´‡á´…")
        return 400
    except UserIsBlocked:
        logger.info(f"{user_id} : BÊŸá´á´„á´‹á´‡á´… TÊœá´‡ Bá´á´›")
        return 400
    except PeerIdInvalid:
        logger.info(f"{user_id} : Uêœ±á´‡Ê€ Iá´… IÉ´á´ á´€ÊŸÉªá´…")
        return 400
    except Exception as e:
        logger.error(f"{user_id} : {e}")
        return 500
     
 # Add premium

@Client.on_message(filters.command("give_premium") & filters.user(Config.ADMIN))
async def give_premium_cmd_handler(client, message):
    if len(message.command) == 3:
        user_id = int(message.command[1])  # Convert the user_id to integer
        time = message.command[2]
        seconds = await get_seconds(time)
        if seconds > 0:
            expiry_time = datetime.datetime.now() + datetime.timedelta(seconds=seconds)
            user_data = {"id": user_id, "expiry_time": expiry_time}  # Using "id" instead of "user_id"
            await db.update_user(user_data)  # Use the update_user method to update or insert user data
            await message.reply_text(f"<i>ğŸ“‘ á´˜Ê€á´‡á´Éªá´œá´ á´€á´„á´„á´‡ss á´€á´…á´…á´‡á´… á´›á´ á´œsá´‡Ê€\n\nÉªá´… - <code>{user_id}</code>\ná´›Éªá´á´‡ - <code>{time}</code></i>")
            await client.send_message(
                chat_id=user_id,
                text=f"<i>á´˜Ê€á´‡á´Éªá´œá´ á´€á´…á´…á´‡á´… á´›á´ Êá´á´œÊ€ á´€á´„á´„á´á´œÉ´á´› êœ°á´Ê€ {time} á´‡É´á´Šá´Ê ğŸ˜€</i>",                
            )
        else:
            await message.reply_text("Invalid time format. Please use '1day for days', '1hour for hours', or '1min for minutes', or '1month for months' or '1year for year'")
    else:
        await message.reply_text("Usage: /give_premium user_id time (e.g., '1day for days', '1hour for hours', or '1min for minutes', or '1month for months' or '1year for year')")

@Client.on_message(filters.private & filters.command(["batch"]))
async def batch_rename(client, message):
    if len(message.command) != 3:
        await message.reply("Usage: /batch start_post_link end_post_link")
        return
     
    start_post_link = message.command[1]
    end_post_link = message.command[2]
    start_post_id = extract_post_id(start_post_link)
    end_post_id = extract_post_id(end_post_link)

    if start_post_id is None or end_post_id is None:
        await message.reply("Invalid post links provided. Usage: /batch start_post_link end_post_link")
        return
     
    source_channel_id = -1001514489559
    dest_channel_id = -1001862896786

    await message.reply_text("Please provide a thumbnail image for the batch. Send a photo.")
    
    batch_data[message.chat.id] = {
        "start_post_id": start_post_id,
        "end_post_id": end_post_id,
        "source_channel_id": -1001514489559,
        "dest_channel_id": -1001862896786,
    }







        
